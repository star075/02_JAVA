package basic.ch08.sec10.exam02;

public class CastingExample {
    public static void main(String[] args) {
        Vehicle vehicle = new Bus();

        vehicle.run();           // ✅ 가능 (인터페이스에 정의된 메서드)
        // vehicle.checkFare();  // ❌ 오류! Vehicle에는 checkFare() 없음

        // 형변환해서 Bus 타입으로 사용
        Bus bus = (Bus) vehicle;
        bus.run();               // ✅ 가능
        bus.checkFare();        // ✅ 가능 (Bus 클래스의 메서드)
    }
}

/*
* ---

## ✅ 개념 정리: 인터페이스 타입 업캐스팅 & 다운캐스팅

### ✔️ 인터페이스 타입으로 업캐스팅
- `Vehicle vehicle = new Bus();`
- 자식 객체를 부모 타입(인터페이스)으로 받는 것 → **업캐스팅**
- 이때 사용할 수 있는 메서드는 **인터페이스에 정의된 메서드만 가능**
- 장점: 다양한 구현체를 같은 타입으로 다룰 수 있어 **코드의 유연성과 확장성 향상**

### ✔️ 필요한 경우에만 다운캐스팅
- `Bus bus = (Bus) vehicle;`
- 인터페이스 타입으로는 접근할 수 없는 **자식 클래스의 고유 기능**을 쓰고 싶을 때 사용
- 다운캐스팅을 통해 구체 클래스 타입으로 다시 변환
- 단, **형변환 전에 실제 객체가 해당 클래스인지 확인**이 필요할 수도 있음 (`instanceof` 등)

---

## ✅ 예시 상황 정리

| 선언 타입      | 접근 가능 메서드            | 설명                           |
|----------------|-----------------------------|--------------------------------|
| `Vehicle`      | `run()`만 가능              | 인터페이스에 정의된 기능만 사용 |
| `Bus`          | `run()`, `checkFare()` 모두 가능 | 구체 클래스의 고유 기능까지 사용 가능 |

---

## ✅ 결론

> **인터페이스 타입으로 설계하면 유연한 코드 작성이 가능하고**,
> **특정 기능이 필요할 땐 다운캐스팅을 통해 확장성 있게 활용할 수 있다!**

---
* */